useEffect: 
useEffect performs side effects to our application In functional components , Side effects can include
tasks such as data fetching, setting up subscriptions, manually modifying the DOM, timers, logging, 
 By default, useEffect runs after every render, which means it is used for operations that need to happen
 after the component has been rendered.
useEffect can optionally accept a second argument, called the dependency array, to control when the 
effect runs
If the array is empty ([]), the effect runs only once after the initial render, similar to componentDidMount.
If the array contains variables (e.g., [state]), the effect will run whenever those variables change.
If no dependency array is provided, the effect runs after every render.

Hoc: 
HOC is a function that takes a component and returns a new component with additional props or behavior
In other words, it's a pattern that allows you to reuse component logic by wrapping a component with 
additional functionality.
HOCs are used for code reuse, logic abstraction, and component composition.
using Hoc we can make our code more reusable ,we can render the ui contionally and can able to perform 
component composition

use: In React, components that are prefixed with use e.g., useState, useEffect, useContext, etc are hooks.
These are special functions provided by React that allow functional components to use state and other
React features
use indicates that the function is a React hook and can only be called inside functional components or custom hooks.
Only call hooks at the top level of a component or a custom hook.
Only call hooks from React functions

controled & uncontroled: 
In React, controlled inputs and uncontrolled inputs refer to how the value of an input field is handled
A controlled input is an input element whose value is controlled by React state.
The value of the input is always synchronized with the component's state.
You explicitly define and update the value via useState
An uncontrolled input is one where the DOM itself manages the input's state.
Instead of React state, the input's value is accessed via a ref.
The value is not controlled by React, so React doesn't need to re-render for every change.
